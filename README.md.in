# Tmds.LibC

Raw bindings to Linux platform APIs for .NET Core.

## Raw bindings

The APIs provided by this package stay as close as possible to the native declarations.
Because the native APIs are different per platform (e.g. linux-arm64 vs linux-x64), the package contains separate assemblies for each platform.

.NET Core will use the appropriate assembly based on the [rid](https://docs.microsoft.com/en-us/dotnet/core/rid-catalog).

## Supported platforms

* linux x64 glibc
* linux arm64 glibc

## Using this package

NuGet.Config

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="tmds" value="https://www.myget.org/F/tmds/api/v3/index.json" />
  </packageSources>
</configuration>
```

console.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>netcoreapp2.1</TargetFramework>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Tmds.LibC" Version="0.1.0-*" />
  </ItemGroup>

</Project>
```

Program.cs

```cs
using System;
using System.Text;
using Tmds.Linux;
using static Tmds.Linux.LibC;

namespace console
{
    class Program
    {
        unsafe static void Main(string[] args)
        {
            var bytes = Encoding.UTF8.GetBytes("Hello world!");
            fixed (byte* buffer = bytes)
            {
                write(STDOUT_FILENO, buffer, bytes.Length);
            }
        }
    }
}
```

## Functions

The following functions are defined in the static class `Tmds.Linux.LibC`:

##FUNCTIONS##

## Structs

The following structs are defined in the `Tmds.Linux` namespace:

##STRUCTS##

## Examples

This section shows some examples. The examples use a `PlatformException` class which is implemented as follows:

```c#
class PlatformException : Exception
{
    public PlatformException(int errno) :
        base(GetErrorMessage(errno))
    {
        HResult = errno;
    }

    public PlatformException() :
        this(LibC.errno)
    {}

    public unsafe static string GetErrorMessage(int errno)
    {
        int bufferLength = 1024;
        byte* buffer = stackalloc byte[bufferLength];

        int rv = strerror_r(errno, buffer, bufferLength);

        return rv == 0 ? Marshal.PtrToStringAnsi((IntPtr)buffer) : $"errno {errno}";
    }
}
```

### Example 1: Socket extension method to set raw socket options

```c#
static class SocketExtensions
{
    public static unsafe void SetRawSocketOption(this Socket socket, int level, int optname, int optval)
    {
        SafeHandle handle = socket.SafeHandle;
        bool refAdded = false;
        try
        {
            handle.DangerousAddRef(ref refAdded);
            int rv = setsockopt(handle.DangerousGetHandle().ToInt32(), level, optname, &optval, sizeof(int));
            if (rv != 0)
            {
                throw new PlatformException();
            }
        }
        finally
        {
            if (refAdded)
                handle.DangerousRelease();
        }
    }
}
```

This extension method can be used with the constants provided by `Tmds.LibC`, for example:
```c#
socket.SetRawSocketOption(SOL_SOCKET, SO_REUSEADDR, 1);
```

### Example 2: Process extension method to request termination

Unix processes can be requested to terminate using the `SIGTERM` signal. The following code adds an extension
method to the `Process` class to send that signal.

```c#
static class ProcessExtensions
{
    public static void Terminate(this Process process)
    {
        if (process.HasExited)
        {
            return;
        }
        int rv = kill(process.Handle.ToInt32(), SIGTERM);
        if (rv == -1 &&
            errno != ESRCH /* process does not exist, assume it exited */)
        {
            throw new PlatformException();
        }
    }
}
```

### Example 3: Creating a temporary directory that is only accessible by the user

```c#
static class FileUtils
{
    public unsafe static string CreatePrivateTempDirectory()
    {
        string path = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
        fixed (byte* pathname = Encoding.UTF8.GetBytes(path))
        {
            int rv = mkdir(pathname, S_IRWXU);
            if (rv == -1)
            {
                throw new PlatformException();
            }
            else
            {
                return path;
            }
        }
    }
}
```